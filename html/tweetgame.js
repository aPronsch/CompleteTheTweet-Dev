//defining a class called TweetGame that will allow a single object to perform all the necessary tasks
// "tweet" refers to the string retrieved from the twitter API
function TweetGame(tweet) {
	
	this.tweet = tweet;
	this.score = 0;
	this.options = [0,0,0,0,0,0];
	this.emoji = "";
	this.userName = document.getElementById("user").innerHTML;
	this.tweetWithBlanks = "";

	var utf = convertToUtf(this.tweet);
	var emo = isolateEmoji(utf);
	this.options = generateOptions(emo);
	this.emoji = translateEmoji(emo);
	this.options[0] = this.emoji;
	positions = findEmojis(utf, emo);
	this.tweetWithBlanks = rebuildStringWithBlanks(utf, emo, positions);

	document.getElementById("score").innerHTML = this.score;
	document.getElementById("user").innerHTML = this.userName;
	document.getElementById("opt1").innerHTML = this.options[0];
	document.getElementById("opt2").innerHTML = this.options[1];
	document.getElementById("opt3").innerHTML = this.options[2];
	document.getElementById("opt4").innerHTML = this.options[3];
	document.getElementById("opt5").innerHTML = this.options[4];
	document.getElementById("opt6").innerHTML = this.options[5];
}

TweetGame.prototype.changeScore = function( magnitude) {
	this.score += magnitude;
	document.getElementById("score").innerHTML = this.score;
	return this.score
}

TweetGame.prototype.checkEmoji = function( emojiIn) {
	return emojiIn === this.emoji;
}

TweetGame.prototype.changeUserName = function(newName) {
	this.userName = newName;
	document.getElementById("user").innerHTML = this.userName;
	return;
}

TweetGame.prototype.newGame = function(tweet) {
	this.tweet = tweet;
	this.options = [0,0,0,0,0,0];
	this.emoji = "";

	var utf = convertToUtf(this.tweet);
	var emo = isolateEmoji(utf);
	this.options = generateOptions(emo);
	this.emoji = translateEmoji(emo);
	this.options[0] = this.emoji;
	positions = findEmojis(utf, emo);
	this.tweetWithBlanks = rebuildStringWithBlanks(utf, emo, positions);

	document.getElementById("opt1").innerHTML = this.options[0];
	document.getElementById("opt2").innerHTML = this.options[1];
	document.getElementById("opt3").innerHTML = this.options[2];
	document.getElementById("opt4").innerHTML = this.options[3];
	document.getElementById("opt5").innerHTML = this.options[4];
	document.getElementById("opt6").innerHTML = this.options[5];
}

// using the parameter "emoji" a similar emoji is generated by decreasing the unicode representation
// if the options reach the lower boundary then emoji are selected above the original value
// returns 0 in options[0] if somehow the emoji codes exit the acceptable range
function generateOptions(emoji) {
	var first = "";
	var second = "";
	var options = [];
	var randomFlag = 0;
	for(var j = 0; j < 12; j++) {
		if(j < 6) {
		first += emoji[j];
		}
		else {
			second += emoji[j];
		}
	}
	var hitLow = 0;
	var hitHigh = 0;
	options[0] = emoji;
	// codes below or above these limits produce garbage values
	var lowerLimit = 56350;
	var upperLimit = 56900;

	var newCode = utfToUnicode(second);
	var original = newCode;

	// generates random offset numbers to produce random emojis
	// this happens only if the selected emoji is not of type "\\ud83d"
	// It would be incredibly complicated to choose similar emojis if 
			//considering different possible prefixes
	var offset = 0;
	var usedVals = [];
	if(first !== "\\ud83d") {
		randomFlag = 1;
		first = "\\ud83d";
		for(var j = 1; j < 6; ++j) {
			offset = Math.floor((Math.random() * 550));
			usedVals[j-1] = offset;
			// this loop checks for duplicate random values
			for(var k = 0; k < 5; k++) {
				if(offset === usedVals[k]) {
					if(offset < 200) {
						++offset;
						usedVals[j-1] = offset;
						break;
					}
					else {
						offset = 0;
					}
					k = 0;
				}
			}
		}
	}
	for(var i = 0; i < 6; ++i) {
		if(randomFlag === 1) {
			newCode = lowerLimit + usedVals[i-1];
		}
		options[i] = String.fromCharCode(utfToUnicode(first));
		if(newCode > lowerLimit && hitLow === 0) {
			--newCode;
			options[i] += String.fromCharCode(newCode);
		}
		else if(newCode === lowerLimit) {
			hitLow = 1;
			newCode = original + 1;
			options[i] += String.fromCharCode(newCode);
		}
		else if (newCode < upperLimit && newCode > lowerLimit) {
			++newCode;
			options[i] += String.fromCharCode(newCode);
		}
		else {
			options [0] = 0;
			return options;
		}
	}
	return options;
}

//this function takes in utf-16 encoding and returns the string representation of an emoji
function translateEmoji(utf) {
	var first = "";
	var second = "";
	var str = "";
	for(var j = 0; j < 12; j++) {
		if(j < 6) {
		first += utf[j];
		}
		else {
			second += utf[j];
		}
	}
	str += String.fromCharCode(utfToUnicode(first));
	str += String.fromCharCode(utfToUnicode(second));
	return str;
}

// this function finds all occurences of the chosen emoji and returns their positions
function findEmojis(utf, emo) {
	var positions = [];
	for(var i = 0; i < utf.length; i++) {
		if(utf[i] === emo) {
			positions.push(i);
		}
	}	
	return positions;
}

// this function replaces all occurences of the given emoji in the given tweet with spaces. 
// It the returns the generated string with blanks
function rebuildStringWithBlanks(utf, emoji, positions) {
	var counter = 0;
	var str = "";
	for(var i = 0; i < utf.length; ++i) {
		if(i === positions[counter]) {
			++counter;
			str += "__";
			continue;
		}
		else if (utf[i].length > 6) {
			str += translateEmoji(utf[i]);
		}
		else {
			str += String.fromCharCode(utfToUnicode(utf[i]));
		}
	}

	document.getElementById("tweet").innerHTML = str;
	document.getElementById("tweet").style.backgroundColor = "#ffffff";
	return str;

}

// this functions takes a utf-16 encoded number and turns it back into unicode.
function utfToUnicode(utfString) {
	var hex = "";
	for(var i = 2; i < 6; i++) {
		hex += utfString[i];
	}
	return parseInt(hex, 16);
}

// converts the given string into its corresponding unicode
function convertToUtf(str) {
	var resUtf = [];
	var realLength = 0;
	var temp = "";
	var c = 1;
	flag = 1;
	for(var i = 0; i < str.length; i++) {
		//stores each utf-16 code into an array
		temp = ("\\u" + ("000" + str[i].charCodeAt(0).toString(16)).substr(-4));

		//emojis come in 2 pieces this if statement makes sure they remain together
		if( flag && temp > "\\ud83c" && i !== 0 && resUtf[i-c] === "\\ud83d") {
			resUtf[i-c] += temp; 
			c++;
			flag = 0;
			continue;
		}
		else {
			resUtf.push(temp);
			flag = 1;
		}
	}
	return resUtf;
}

// this method isolates the last occurring emoji in a given utf-16 sequence
// return value is the utf-16 translation of the unicode for the emoji
function isolateEmoji(unicode) {
	var chosen = "";
	for(var i = unicode.length - 1; i >= 0; i-- ) {
		if(unicode[i].length > 6 && chosen === "") {
			if(i === unicode.length) {
				continue;
			}
			// certain complex emojis have a joiner char 
			// These complex emojis are ignored to make the process less complicated
			if(i > 0 && unicode[i-1] === "\\u200d" ||
			  i < unicode.length -1 && unicode[i+1] === "\\u200d") {
				continue;
			}
			else {
				var prefix = "";
				for(var j = 0; j < 6; ++j) {
					prefix += unicode[i][j];
				}
				chosen = unicode[i];
			}
		}	
	}
	return chosen;
}

function test() {
	var game = new TweetGame("yo🤐🤐 y😴o y🤐yo😂💛😂👨‍👩‍👧‍👦");
	game.changeScore(5);
	game.changeUserName("Matt");
	console.log(game.score);

	document.getElementById("tweet").innerHTML = game.tweetWithBlanks;
	console.log(game.emoji);
	console.log(game.options);
	console.log(game.checkEmoji("😂"));
	console.log(game.userName);

	game.newGame("some😂 random words to ignore 🤐🤐🤴😥😕🙄🤡🤳🤐");
	game.changeScore(5);
	console.log(game.score);
	console.log(game.tweetWithBlanks);
	console.log(game.emoji);
	console.log(game.options);
	console.log(game.checkEmoji("😂"));
	console.log(game.userName);
}
